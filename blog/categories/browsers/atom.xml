<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Browsers | TJ VanToll]]></title>
  <link href="http://tjvantoll.com/blog/categories/browsers/atom.xml" rel="self"/>
  <link href="http://tjvantoll.com/"/>
  <updated>2012-06-10T16:42:37-04:00</updated>
  <id>http://tjvantoll.com/</id>
  <author>
    <name><![CDATA[TJ VanToll]]></name>
    <email><![CDATA[tj.vantoll@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Browser CSS Parsing Discrepancies]]></title>
    <link href="http://tjvantoll.com/2012/06/10/browser-css-parsing-discrepancies/"/>
    <updated>2012-06-10T22:24:00-04:00</updated>
    <id>http://tjvantoll.com/2012/06/10/browser-css-parsing-discrepancies</id>
    <content type="html"><![CDATA[<p>Possibly the most frustrating thing that can happen during web development is when things look or behave differently in different browsers for no apparent reason.</p>

<p>One of the major features of HTML5 is a <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html">parsing algorithm</a> that specifies not only how to handle well formed markup, but also what to do with invalid HTML.</p>

<p>The <a href="http://www.w3.org/TR/CSS2/syndata.html#parsing-errors">CSS specification</a> actually does the same.  In fact, it goes into explicit detail for how to handle a wide variety of nonsense syntax that it might encounter.  For example...</p>

<!--more-->


<p><strong>Declarations with unkown properties should be ignored.</strong></p>

<p>``` css
h1 { color: red; foo: bar; }</p>

<p>/<em> foo is an unkown property so the browser should interpret this as... </em>/
h1 { color: red; }
```</p>

<p><strong>Illegal values should be ignored.</strong></p>

<p>``` css
h1 { float: 'foo'; }</p>

<p>/<em> foo is an invalid value for the float property and should be ignored </em>/
```</p>

<p>These are just a sampling of what is specified.  The above rules are well documented and consistenly followed by all browsers.  Unfortunately that is not the case as we get into more complicated scenarios.</p>

<h3>Malformed Strings in CSS</h3>

<p>Take a guess, what <em>should</em> happen with the following:</p>

<p>``` html</p>

<div data-number="one">one</div>


<div data-number="two">two</div>


<p>​</p>



<p>```
The relevant portion of the specification states that...</p>

<p><blockquote><p>User agents must close strings upon reaching the end of a line (i.e., before an unescaped line feed, carriage return or form feed character), but then drop the construct (declaration or rule) in which the string was found.</p><footer><strong>CSS Specification</strong> <cite><a href='http://www.w3.org/TR/CSS2/syndata.html#parsing-errors'>www.w3.org/TR/CSS2/&hellip;</a></cite></footer></blockquote></p>

<p>Let's take this one rule at a time.</p>

<pre><code>background: url("some-url);
</code></pre>

<p>Per the spec you would expect the <code>background</code> to be ignored because of the malformed string, and it is in all browsers I tested.</p>

<pre><code>color: red;
</code></pre>

<p>This is kind of in a gray area.  The spec says that the <em>construct in which the unclosed string was found</em> should be dropped, but what about subsequent rules that were encountered before a new line?</p>

<pre><code>color: blue;
</code></pre>

<p>Per the spec you would expect this to be interpreted since a new line character occurred after the unclosed double quote.</p>

<pre><code>border: 2px solid black;
</code></pre>

<p>Along the same lines you would also expect a border to be around both divs since by then normal parsing of the stylesheet should resume.</p>

<p>Here's what a sampling of browsers actually do.</p>

<table>
    <thead>
        <tr>
            <th>Browser</th>
            <th>Div one color</th>
            <th>Div two color</th>
            <th>Border around the divs</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Chrome 19</td>
            <td class="red">Red</td>
            <td class="blue">Blue</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Safari 5.1.7</td>
            <td class="red">Red</td>
            <td class="blue">Blue</td>
            <td>Yes</td>
        </tr>        
        <tr>
            <td>Firefox 12</td>
            <td>Black</td>
            <td>Black</td>
            <td>No</td>
        </tr>        
        <tr>
            <td>Opera 11.62</td>
            <td>Black</td>
            <td>Black</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Opera Mobile</td>
            <td>Black</td>
            <td>Black</td>
            <td>No</td>
        </tr> 
        <tr>
            <td>iOS 5</td>
            <td class="red">Red</td>
            <td class="blue">Blue</td>
            <td>Yes</td>
        </tr> 
        <tr>
            <td>Android 2+</td>
            <td class="red">Red</td>
            <td class="blue">Blue</td>
            <td>Yes</td>
        </tr> 
        <tr>
            <td>Internet Explorer 7</td>
            <td>Black</td>
            <td>Black</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Internet Explorer 8</td>
            <td>Black</td>
            <td>Black</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Internet Explorer 9</td>
            <td>Black</td>
            <td>Black</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Internet Explorer 10</td>
            <td>Black</td>
            <td>Black</td>
            <td>No</td>
        </tr>        
    </tbody>
</table>


<p>You can see what your browser does here.</p>

<iframe style="width: 100%; height: 120px;" src="http://jsfiddle.net/tj_vantoll/PHKLz/3/embedded/result,html,css/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h3>Results</h3>

<p>WebKit based browsers are evaluating all rules after a semicolon is encountered and all other browsers stop in their tracks and don't evaluate any other rules.  The same results occur with some other common fat finger situations.</p>

<p>``` css
/<em> Notice the mix of single and double quote in the url property value. </em>/
[data-number='one'] { background: url("some_url'); color: red; }
[data-number='two'] { color: blue; }
/<em> In WebKit browsers the color: blue; will be evaluated, in others it will not be. </em>/</p>

<p>/<em> Same thing if there's an malfored selector (notice the missing single quote in the selector. </em>/
[data-number=one'] { color: red; }
[data-number='two'] { color: blue; }
/<em> Again in Webkit color: blue; will be evaluated, in others it will not be. </em>/
```</p>

<h3>What Could Possibly Go Wrong?</h3>

<p>Frankly, since this is an error situtation I don't think many developers would care what the browser does with this.  If the rules aren't evaluated it becomes pretty clear there's an issue and it becomes pretty easy to find and clean up the issue.  What is important to developers is that the results are consistent.  The danger here is if you make a quick fix to a CSS file, fat finger some quotes, and only test in WebKit, you could catastrophically break your styling in non-WebKit browsers.</p>

<h3>Avoiding Issues</h3>

<p>The obvious way to avoid running into issues is to test your code in all browsers.  However, with the amount of browsers, devices, etc... there are to test on that's not always feasible; especially for trivial changes.</p>

<p>Modern editors with syntax highlighting can help you find malformed strings by creating an obvious syntax highlighting problem.  If yours doesn't you might want to consider switching to one that does.</p>

<p>Furthermore, tools like <a href="http://csslint.net/">CSS Lint</a> can help detect issues <a href="https://github.com/stubbornella/csslint/wiki/IDE-integration">via your editor / IDE</a> or at build time by <a href="https://github.com/stubbornella/csslint/wiki/Command-line-interface">incorporating them into a Node.js or Ant build process</a>.</p>

<h3>Conclusion</h3>

<p>While the CSS specification tries to standarize what to do with invalid CSS browsers still handle some situations differently.  Make sure your editor or build process can help detect silly typos, and attempt to test your code in a variety of browsers, even for trivial changes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[window.showModalDialog: What It is and Why You Should Never Use It]]></title>
    <link href="http://tjvantoll.com/2012/05/02/showmodaldialog-what-it-is-and-why-you-should-never-use-it/"/>
    <updated>2012-05-02T22:37:00-04:00</updated>
    <id>http://tjvantoll.com/2012/05/02/showmodaldialog-what-it-is-and-why-you-should-never-use-it</id>
    <content type="html"><![CDATA[<p>Ah, 1997.  The first browser war was in full force, and Microsoft was busy adding proprietary new features to compete with Netscape Navigator.  One of those features was introducing a common OS UI element into the browser - modal dialogs.  Internet Explorer 4 launched with a <code>showModalDialog</code> method on the global <code>window</code> object.  When called it displays a dialog that the user has to deal with before interacting with the rest of the page.</p>

<p>Fast forward a few years and Internet Explorer had won the war, 95+ percent of us were using IE6.  Consequently a whole lot of web applications were designed around many of the proprietary features that IE had added.  Interestingly several of these have recently been added to the HTML5 specification including <a href="http://www.w3.org/TR/html5/embedded-content-0.html#dom-innerhtml">innerHTML</a>, <a href="http://html5.org/specs/dom-parsing.html#insertadjacenthtml%28%29">insertAdjacentHTML</a>, <a href="http://html5.org/specs/dom-parsing.html#outerhtml">outerHTML</a>, and… <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dialogs-implemented-using-separate-documents">window.showModalDialog</a>.</p>

<p>So now that <code>window.showModalDialog</code> has been standardized should you be using it?</p>

<p><strong>No.</strong></p>

<p>In general the idea of putting a native dialog implementation into the browser was a really good idea, but  <code>window.showModalDialog</code> was a bad implementation that is riddled with issues and poor browser support.<!--more--></p>

<h3>Modal Dialogs</h3>

<p>So why did Microsoft add modal dialogs to begin with?  They're actually a heavily used UI element in most all computer interfaces.  Try to shut off your phone, tablet, laptop, etc.. and you're almost certainly going to be presented with a modal dialog asking you to confirm your decision before being allowed to shut it down.  What makes it modal is the fact that you are forced to make a selection before you do anything else.</p>

<p>It's oftentimes convenient from a usability stand point to get some form of feedback from a user before allowing them to continue.  <code>showModalDialog</code> was simply Microsoft's attempt to bring this UI element to the web.</p>

<h3>Implementation</h3>

<p>To use the <code>showModalDialog</code> method you simply call it with a URL.</p>

<p><code>javascript window.showModalDialog Basic Usage
window.showModalDialog('http://google.com');
</code></p>

<p>This will open up a modal dialog with Google loaded in it.  In and of itself this isn't all that useful.  Usually if you're showing a modal dialog you want to get some information back from it.  This is where the window.returnValue comes into play.</p>

<h4>window.returnValue</h4>

<p>``` html window.returnValue Example</p>

<!-- page.html -->


<p>&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;script&gt;
  var result = window.showModalDialog('modal.html');
  console.log(result); //'foo'
&lt;/script&gt;
</code></pre>

<p>  </head>
  <body>
  </body>
</html></p>

<!-- modal.html -->


<p>&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;script&gt;
  window.returnValue = 'foo';
  window.close();
&lt;/script&gt;
</code></pre>

<p>  </head>
  <body>
  </body>
</html>
```</p>

<p>In this example when page.html is loaded it will immediately open up a modal dialog with modal.html loaded in it.  It will then block until the modal dialog returns control.  The JavaScript interpreter will literally pause execution as if you had a breakpoint set at that line of code and wait for the result of the modal dialog.</p>

<p>When modal.html loads it will assign a value of 'foo' to <code>window.returnValue</code> and close itself via <code>window.close()</code>.  The opening window (page.html) will get control back, resume execution, and log the return value of 'foo'.</p>

<h4>window.dialogArguments</h4>

<p>If you want to pass information to the modal dialog you can do so via the second parameter of <code>window.showModalDialog</code>.  Those values will be available in the modal dialog's <code>window.dialogArguments</code> property.</p>

<p>``` html window.returnValue Example</p>

<!-- page.html -->


<p>&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;script&gt;
  window.showModalDialog('modal.html', 'foo');
&lt;/script&gt;
</code></pre>

<p>  </head>
  <body>
  </body>
</html></p>

<!-- modal.html -->


<p>&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;script&gt;
  alert(window.dialogArguments); //'foo'
  window.close();
&lt;/script&gt;
</code></pre>

<p>  </head>
  <body>
  </body>
</html>
```</p>

<h4>Further Options</h4>

<p>A third parameter to <code>window.showModalDialog</code> is available to customize the look and behavior of the modal dialog.  The <a href="https://developer.mozilla.org/en/DOM/window.showModalDialog">MDN article on showModalDialog</a> has these well documented.</p>

<h3>Modal Dialog == A Brand New Window</h3>

<p>Note that in all these examples modal.html is a full HTML document, not a snippet that is injected in.  This is a characterizing feature of <code>window.showModalDialog</code>.  It's really just two completely separate windows communicating with each other.  The fact that you have two separate windows and DOMs means you don't have to worry about JS &amp; DOM conflicts, which is appealing if you have a lot of bad JavaScript with a cluttered global scope.  But mostly this just adds unnecessary complexity, complicates the browser implementation, and contributes to a number of bugs (see below).</p>

<p><blockquote><p>"You should only use one browser window ever, as a Web app author."</p><footer><strong>Ian Hickson (HTML 5 spec maintainer)</strong> <cite><a href='http://www.mail-archive.com/public-webapi@w3.org/msg03345.html'>www.mail-archive.com/&hellip;</a></cite></footer></blockquote></p>

<h3>Browser Support</h3>

<p>IE obviously supports this function and has since IE4, but what about the other browsers?  Firefox added support in version 3 and Safari added support in 5.1.  Opera doesn't support it at all.</p>

<p>Chrome has supported it since an early version but has some serious bugs with its implementation.  Most importantly the window Chrome displays isn't modal (see <a href="http://code.google.com/p/chromium/issues/detail?id=16045">Chromium bug #16045</a>), meaning, the user is able to interact with the original window before dealing with the modal dialog, which kind of defeats the whole purpose.  Another big one is that <code>window.returnValue</code> will be lost if any sort of redirect or form submission is done in the modal dialog (see <a href="http://code.google.com/p/chromium/issues/detail?id=42939">Chromium bug #42939</a>).</p>

<p>Despite these issues Chrome did do one thing right.  While it's important that modal dialogs prevent the user from interacting with the originating window, there's no reason the user shouldn't be allowed to interact with other tabs or native browser controls (back/forward, favorites, address bar, etc). Chrome is the only browser that allows this - IE, Firefox, and Safari do not.  This is actually a big annoyance to the end user.  IE, Firefox, and Safari don't even allow you to minimize or close the browser until you've dealt with the modal dialog.</p>

<h3>More Issues</h3>

<h4>Modal Dialog == Popup</h4>

<p>The biggest issue with modal dialogs is that Firefox, Chrome, and Safari all treat them as popups by default and block them.  A user has to explictly allow the popup in order to see your modal dialog.  In my experience users usually get frustrated and leave at that point.</p>

<h4>Debugging</h4>

<p>The debugging experience for <code>window.showModalDialog</code> is horrible.  IE as recent as version 9 won't let you open their dev tools up in the modal dialog… at all.  Firefox, Chrome, and Safari will let you open FireBug / Web Inspector, but good luck debugging any script that happens when the dialog is opened.  You're basically forced to alert like it's 1999 to determine what's going on.  Also just a word of warning, IE <strong>LOVES</strong> to cache modal dialogs.</p>

<h4>Mobile</h4>

<p>Currently no major mobile browsers support <code>window.showModalDialog</code>, so if you're looking for any sort of tablet / mobile support you need to stay away.</p>

<h3>Why was this added to HTML5?</h3>

<p>So why have other browsers added support for this method and why was it added to the HTML5 spec?  It's mostly because in the IE6 days 1.2 bajillion applications were written to be extremely dependent on <code>window.showModalDialog</code>.  I can say that I personally work at an enterprise that has its fair share of those applications, and you can see many comments demanding enterprise application support on the various Chrome bugs (see <a href="http://code.google.com/p/chromium/issues/detail?id=4202">#4202</a>, <a href="http://code.google.com/p/chromium/issues/detail?id=16045">#16045</a>, &amp; <a href="http://code.google.com/p/chromium/issues/detail?id=42939">#42939</a>).</p>

<p>Refactoring these applications is no small task, and browsers that want to win market share are catering to them to gain support.</p>

<p><blockquote><p>"At this point, browsers have to support it, there's too much content out there that uses it."</p><footer><strong>Ian Hickson</strong> <cite><a href='http://www.mail-archive.com/public-webapi@w3.org/msg03363.html'>www.mail-archive.com/&hellip;</a></cite></footer></blockquote></p>

<h3>Better Alternatives</h3>

<p>Given all the issues outlined above, it is not a good idea to use <code>window.showModalDialog</code> in new development (or any development for that matter).  So what should you use?  There's no shortage of choices, basically all JavaScript frameworks provide an alternative (see <a href="http://livedocs.dojotoolkit.org/dijit/Dialog">Dojo</a>, <a href="http://mootools.net/forge/p/ascribe_dialog">MooTools</a>, &amp; <a href="http://yuilibrary.com/yui/docs/overlay/">YUI</a>).</p>

<p>Personally I would highly recommend <a href="http://jqueryui.com/demos/dialog/">jQuery UI's dialog</a>.  It has a clean API, is highly customizable, extendable, and is themeable through <a href="http://jqueryui.com/themeroller/">jQuery UI's theme roller</a>.</p>

<h3>Moving Forward</h3>

<p>When asked "What’s your fave feature that didn’t get into HTML 5 that you’d put into HTML 6?", Ian Hickson stated in a 2009 interview that:</p>

<p><blockquote><p>In-window modal dialogs or dialog box—the kind of prompt you get when the computer asks you a question and won’t let you do anything else until you answer the question. For instance, the window that comes up when you say "Save As…" is usually a modal dialog.</p></p><p><p>Right now people fake it with divs and complicated styles and script. It would be neat to just be able to say "make this section a modal dialog". Like showModalDialog(), but within the page instead of opening a new window with a new page.</p></p><p><p>I’d add it to HTML 5, but there are so many new features already that we need to wait for the browsers to catch up.</p><footer><strong>Ian Hickson</strong> <cite><a href='http://www.webstandards.org/2009/05/13/interview-with-ian-hickson-editor-of-the-html-5-specification/'>www.webstandards.org/2009/05/13/&hellip;</a></cite></footer></blockquote></p>

<p>Good news, <a href="http://dev.w3.org/html5/spec/commands.html#the-dialog-element">the dialog element</a> has recently been added to the HTML spec.  It includes a <code>showModal</code> method as well as a <code>returnValue</code> property that mimics <code>window.returnValue</code>.  The bad news?  It will be a long time before this element is useable  in all browsers.  The good news?  This would be a relatively easy element to <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">polyfill</a>, so once some implementations make their way into browsers, developers could make a functional version for older browsers with the same API.</p>

<h3>Conclusion</h3>

<p><code>window.showModalDialog</code> is an old API that has been retroactively standardized; but that doesn't mean you should actually be using it.  If you're still maintaining code using this try to get off of it as soon as possible.  That being said the idea of having native dialog capabilities built into the browser wasn't a bad idea.  Hope may be on the way with the dialog element that was recently added to the HTML5 spec.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Styling Disabled Form Fields]]></title>
    <link href="http://tjvantoll.com/2012/03/17/Styling-Disabled-Form-Fields/"/>
    <updated>2012-03-17T00:00:00-04:00</updated>
    <id>http://tjvantoll.com/2012/03/17/Styling-Disabled-Form-Fields</id>
    <content type="html"><![CDATA[<p>Form fields can be disabled by simply adding the <code>disabled</code> attribute.</p>

<p><code>html Simple Disabled Fields
&lt;input type="text" disabled /&gt;
&lt;textarea disabled&gt;&lt;/textarea&gt;
&lt;select disabled&gt;&lt;/select&gt;
</code></p>

<p>Disabled fields cannot be interacted with by the user; the browser will not allow the field to receive focus or be tabbed to.  For an intuitive UI it's important that disabled fields are clearly evident to the user.  Users are easily confused and frustrated when attempting to interact with fields that they are not able to.</p>

<p>To apply custom styling to disabled fields you can add CSS rules that target <code>input:disabled</code>, <code>select:disabled</code>, &amp; <code>textarea:disabled</code>. (Note: IE doesn't support the <a href="https://developer.mozilla.org/En/CSS/%3Adisabled">disabled pseduo class</a> until IE9, so you'll need to use <code>input[disabled]</code>, <code>select[disabled]</code>, &amp; <code>textarea[disabled]</code> <a href="https://developer.mozilla.org/en/CSS/Attribute_selectors">attribute selectors</a> if IE &lt; 9 support is important for you.  It'll work just the same.)</p>

<p>While you <i>can</i> provide custom disabled field styling, it's not generally a good idea.  All browsers come with default styling for these fields that attempt to mesh with native UI elements in the OS.  Also, users have a certain expectation for what disabled fields look like in their preferred web browser and it's best not to mess with that.</p>

<p>Unfortunately some browser's default styling is less than ideal.  <!--more-->To best show this I've created a <a href="http://jsfiddle.net/ygwnh/12/">test case</a> with the most common form elements and recorded a rendering of the test case in a large number of browser / OS combinations.  Since some of the styles are more evident when a the element is selected and/or has a value, I included both a grouping with no <code>selected</code> or <code>value</code> attributes, and another with those set.</p>

<h3>Markup</h3>

<p>Here's the markup I used for the test cases, some very basic form fields with the <code>disabled</code> attribute.</p>

<h4>No Value / Selected Attributes</h4>

<p>``` html Markup Used to Generate the Examples http://jsfiddle.net/ygwnh/12/</p>

<table>
    <thead>
        <tr>
            <th>Enabled</th>
            <th>Disabled</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><input type="text" /></td>
            <td><input type="text" disabled /></td>
        </tr>
        <tr>
            <td><input type="checkbox" /></td>
            <td><input type="checkbox" disabled /></td>
        </tr>
        <tr>
            <td><input type="radio" /></td>
            <td><input type="radio" disabled /></td>
        </tr>
        <tr>
            <td><select></select></td>
            <td><select disabled></select></td>
        </tr>
        <tr>
            <td><textarea></textarea></td>
            <td><textarea disabled></textarea></td>
        </tr>
    </tbody>
</table>


<p>```</p>

<h4>With Value / Selected Attributes</h4>

<p>``` html Markup Used to Generate the Examples http://jsfiddle.net/ygwnh/12/</p>

<table>
    <thead>
        <tr>
            <th>Enabled w/Value</th>
            <th>Disabled w/Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><input type="text" value="Value" /></td>
            <td><input type="text" disabled value="Value"></td>
        <tr>
            <td><input type="checkbox" checked /></td>
            <td><input type="checkbox" disabled checked /></td>
        </tr>
        <tr>
            <td><input type="radio" checked /></td>
            <td><input type="radio" disabled checked /></td>
        </tr>
        <tr>
            <td><select><option selected>Value</option></select></td>
            <td><select disabled><option selected>Value</option></select></td>
        </tr>
        <tr>
            <td><textarea>Value</textarea></td>
            <td><textarea disabled>Value</textarea></td>
        </tr>
    </tbody>
</table>


<p>  <br/>
```</p>

<h3>Results</h3>

<p>You can view <a href="/images/posts/2012-03-17/All.html">all the results on one page</a> or see individual ones listed below.</p>

<h4>Windows</h4>

<ul>
<li><a href="/images/posts/2012-03-17/IE6.png" title="IE6">IE6</a></li>
<li><a href="/images/posts/2012-03-17/IE7.png" title="IE7">IE7</a></li>
<li><a href="/images/posts/2012-03-17/IE8.png" title="IE8">IE8</a></li>
<li><a href="/images/posts/2012-03-17/IE9.png" title="IE9">IE9</a></li>
<li><a href="/images/posts/2012-03-17/IE10.png" title="IE10">IE10</a></li>
<li><a href="/images/posts/2012-03-17/Windows-Chrome-17.png" title="Windows - Chrome 17">Chrome 17</a></li>
<li><a href="/images/posts/2012-03-17/Windows-Safari-5.1.png" title="Windows - Safari 5.1">Safari 5.1</a></li>
<li><a href="/images/posts/2012-03-17/Windows-Firefox-10.png" title="Windows - Firefox 10">Firefox 10</a></li>
<li><a href="/images/posts/2012-03-17/Windows-Opera-11.61.png" title="Windows - Opera 11.61">Opera 11.61</a></li>
</ul>


<h4>OS X</h4>

<ul>
<li><a href="/images/posts/2012-03-17/OSX-Chrome-17.png" title="OSX - Chrome 17">Chrome 17</a></li>
<li><a href="/images/posts/2012-03-17/OSX-Safari-5.1.png" title="OSX - Safari 5.1">Safari 5.1</a></li>
<li><a href="/images/posts/2012-03-17/OSX-Firefox-11.png" title="OSX - Firefox 11">Firefox 11</a></li>
<li><a href="/images/posts/2012-03-17/OSX-Opera-11.61.png" title="OSX - Opera 11.61">Opera 11.61</a></li>
</ul>


<h4>Mobile</h4>

<ul>
<li><a href="/images/posts/2012-03-17/iOS-5.png" title="iOS 5">iOS 5</a></li>
<li><a href="/images/posts/2012-03-17/Android-2.3.png" title="Android 2.3">Android 2.3</a></li>
<li><a href="/images/posts/2012-03-17/Opera-Mobile.png" title="Opera Mobile">Opera Mobile</a></li>
</ul>


<h3>Findings</h3>

<p>In general browsers add some combination of <code>opacity</code>, a grayish <code>background-color</code>, and a grayish <code>color</code> to the element to create the disabled effect.  For the most part browsers do a pretty good job making it evident that the fields are disabled.</p>

<p>There are exceptions though.  One glaring issue is the display of disabled text inputs and textareas in IE &lt; 10; when no text is present it's impossible to tell whether the field is disabled.  In Windows, all non-IE browsers simply apply a <code>background-color</code> of <code>#EBEBE4</code> to all disabled elements.  Unfortunately, IE &lt; 10 doesn't do much of anything to designate text inputs and textareas as disabled other than change the color of the text, which, doesn't work out all that well when there's no text present.</p>

<h3>Normalizing IE</h3>

<p>To normalize the display of disabled fields in IE we need to be able to target IE &lt;= 9 with CSS.  Why?  We don't want to override the default styling whenever possible.  As mentioned earlier browsers apply different styling to attempt to match native UI elements.  If you blindly apply a background-color to all disabled elements, you'll do so in Windows, OS X, Linux, iOS, Android, etc… as well as any future devices where it might look horrible, or worse, confuse the user.</p>

<p>So back to selecting IE &lt;= 9.  In my opinion the most elegant way to do this is use <a href="http://msdn.microsoft.com/en-us/library/ms537512.aspx">IE's conditional comments</a> to apply classes to the HTML node.  This approach was <a href="http://paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/">first proposed by Paul Irish in 2008</a> and is used in the <a href="http://html5boilerplate.com/">HTML5 boilerplate</a>.  There are many variations but in this case we only need to worry about IE &lt;= 9.</p>

<p>``` html Applying a Class to IE &lt;= 9</p>

<!--[if lte IE 9 ]> <html class="lte9"> <![endif]-->


<!--[if (gt IE 9)|!(IE)]><!-->


<p> <html class=""> <!--<![endif]-->
```</p>

<p>Then we can apply the <code>background-color</code> as such:</p>

<p>``` css Normalizing the Disabled Field Display for Windows
.lte9 input[type='text'][disabled], .lte9 textarea[disabled] {</p>

<pre><code>background-color: #EBEBE4;
</code></pre>

<p>}
```</p>

<p>Alternatively you could use IE's conditional comments to apply these rules directly:</p>

<p>``` html Using IE's Conditional Comments</p>

<!--[if lte IE 9 ]>
    <style>
        input[type='text'][disabled], textarea[disabled] {
            background-color: #EBEBE4;
        }
    </style>
<!--<![endif]-->


<p>```</p>

<p>Either of these approaches will normalize the display of disabled text inputs and textareas on Windows.</p>

<p><img src="/images/posts/2012-03-17/IE-Before-and-After.png" alt="IE Before and After" /> <!-- http://jsfiddle.net/vCdcr/show/ --></p>

<h3>Normalizing IE6</h3>

<p>The above solution will not affect the display of these elements in IE6 because it does not support CSS attribute selectors.  Therefore, if you're still supporting IE6 and the display of disabled fields is important to your UI you'll need some other sort of hook on the node.  For example a class will work:</p>

<p>``` html IE6 Disabled Field Markup</p>

<!--[if IE 6 ]> <html class="ie6"> <![endif]-->


<!--[if (gt IE 6)|!(IE)]><!-->


<p> <html class=""> <!--<![endif]--></p>

<p>/<em> … </em>/</p>

<p><input type="text" disabled class="disabled" />
<textarea disabled class="disabled">
```</p>

<p>Then you can apply the following CSS:</p>

<p>``` css IE6 Disabled Field Styling
.ie6 input.disabled, .ie6 textarea.disabled {</p>

<pre><code>background-color: #EBEBE4;
</code></pre>

<p>}
```</p>

<h3>Other Issues</h3>

<p>A number of browsers including all OS X browsers except Opera, Android, and iOS do a poor job making textareas appear disabled, in some cases even when text is present.  If your UI contains disabled textareas it's probably worth adding a little bit of opacity to compensate for browsers that don't make it very apparent that you cannot interact with them.</p>

<p>``` css Normalizing Textarea Disabling
textarea:disabled {</p>

<pre><code>opacity: 0.5;
</code></pre>

<p>}
```</p>

<p>The effect is subtle but can make a big difference in helping the user to recognize that the field is disabled, especially if multiple textareas are near each other.  Here's an example from Chrome 17 on OS X:</p>

<p><img src="/images/posts/2012-03-17/OSX-Before-and-After.png" alt="OSX Before and After" /> <!-- http://jsfiddle.net/JpNav/1/show/ --></p>

<h3>Summary</h3>

<p>Browsers have default styling for disabled fields that is usually pretty good at visually indicating that the field cannot be interacted with.  In situations where the browser default isn't ideal, custom styling can be applied.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IE7 Attribute Selector Bugs]]></title>
    <link href="http://tjvantoll.com/2012/03/08/IE7-Attribute-Selector-Bugs/"/>
    <updated>2012-03-08T00:00:00-05:00</updated>
    <id>http://tjvantoll.com/2012/03/08/IE7-Attribute-Selector-Bugs</id>
    <content type="html"><![CDATA[<p>The CSS attribute selector allows you to select HTML elements based on their attributes.  For example, take the following markup:</p>

<p>``` html Simple List</p>

<ul>
    <li id="item1"></li>  <!-- #1 -->
    <li id="item2"></li>  <!-- #2 -->
    <li></li>             <!-- #3 -->
</ul>


<p>```</p>

<!--more-->


<p>In a compliant browser, here are some selectors you can use to target these list items.</p>

<p><code>css Selectors to Target the List
li             /* Selects #1, #2, #3 */
li[id]         /* Selects #1, #2 */
li[id=item1]   /* Selects #1 */
li[id='item1'] /* Selects #1, single quotes are valid */
li[id="item2"] /* Selects #1, double quotes are valid too */
li[id^=item]   /* Selects #1, #2, ^ = starts with */
li[id$=1]      /* Selects #1, $ = ends with */
li[id*=item]   /* Selects #1, #2, * = contains */
</code></p>

<h3>Enter IE7</h3>

<p>This is all well and good in most all modern browsers.  Unfortunately IE7 is buggy when handling this selector.  For those of use that are still unlucky enough to be supporting it, I thought it would be nice to have some of these documented.</p>

<h3>DOM Attributes == HTML Attributes?</h3>

<p>Some DOM attributes have different names than the HTML attributes to avoid conflicts with JavaScript reserved words.  Specifically in this case, DOM nodes have <code>htmlFor</code> and <code>className</code> attributes to avoid JavaScript reserved words <code>for</code> and <code>class</code>.</p>

<p>``` html htmlFor and className
<label class="foo" for="name" id="nameLabel">Name:</label>
<input type="text" name="name" id="name" /></p>

<script>
    document.getElementById('nameLabel').for; //undefined
    document.getElementById('nameLabel').htmlFor //'name'
    document.getElementById('nameLabel').class //undefined
    document.getElementById('nameLabel').className //'foo'
</script>


<p>```</p>

<p>In IE8+ (and everywhere else for that matter) the following attribute selector will select the label:</p>

<p><code>css Standard Attribute Selector
label[for='name']
</code></p>

<p>In IE7 this won't work.  You'll need to use the incorrect <code>htmlFor</code> attribute:</p>

<p><code>css IE7 for Attribute Selector
label[htmlFor='name']
</code></p>

<p>So if you're still supporting IE7 you'll almost certainly want to include them together:</p>

<p><code>css Combined Selector
label[for='name'], label[htmlFor='name']
</code></p>

<p>Along the same lines, IE7 will incorrectly select attributes based on the className attribute:</p>

<p><code>css IE7 class Attribute Selector
label[className='name']
</code></p>

<p>Fortunately IE7 also supports selecting using <code>class</code>.</p>

<p><code>css class Attribute Selector
label[class='name']
</code></p>

<p>IE8 fixed both of these bugs and selecting for the attributes <code>htmlFor</code> and <code>className</code> no longer work.</p>

<h3>Empty Attributes</h3>

<p>It's impossible to target empty attributes via CSS in IE7.  As an example, let's say you apply a <a href="http://html5doctor.com/html5-custom-data-attributes/">custom HTML5 data attribute</a> to nodes at random throughout the DOM.  Let's say you want to select only the ones that have an empty value, for example the h3 below:</p>

<p>``` html Headings to Select</p>

<h1 data-state="foo">Top Heading<h1>
<h2 data-state="bar">Sub Heading<h2>
<h3 data-state="">Another Heading<h3>
```

You would write this selector and call it a day:

``` css Empty Attribute Selector
[data-state='']
```

Except it won't work in IE7.  There is simply no way to target empty attributes via CSS in IE7.  So how can you replicate this functionality?  For better or worse JavaScript is the only client side option to handle this.

[querySelectorAll](http://caniuse.com/queryselector) isn't supported until IE8, so you need a selector engine to target these nodes.  Here's how you can do it in jQuery:

``` javascript Selecting Nodes with Empty Attribute - jQuery
$('[data-state=""]');
```

If you're using [Dojo](http://dojotoolkit.org) yet another step is necessary.  For whatever reason running…

``` javascript JavaScript Selecting Nodes with Empty Attribute - Dojo
dojo.query('[data-state=""]');
```

…returns not only the nodes with empty attributes, but also all the nodes that don't have the attribute declared at all!  Furthermore, <code>dojo.query('[data-state]')</code> incorrectly doesn't return nodes that have the attribute with an empty value.  So you need the following approach to select the nodes in IE7.

``` javascript Functioning IE7 Approach
dojo.query('*').forEach(function(element) {
    if (dojo.hasAttr(element, 'data-state') && 
      dojo.attr(element, 'data-state') == '') {
        //Safe to finally apply your styling here.
    }
});
```

Note that when using any of the JavaScript based solutions it's recommended to leave the CSS in place.  Yes this is dual maintenance, but it avoids a potential [FOUC](http://en.wikipedia.org/wiki/FOUC).  Fortunately ALL of this nonsense is fixed in IE8.

### Descendant Selector Typos

Let's say you have the following markup.

``` html Sample HTML
<div data-state='active'>
    <p>Some text</p>
</div>
```

…and you want to apply some styling to the paragraph, maybe something like this:

``` css Descendant Selector
div[data-state='active']p {
    color: red;
}
```

Notice how there's no space between the "]" and the "p", that's a syntax error, right?  Correct… except in IE7!  IE7 will incorrectly parse this as if a space were there and change the color of the paragraph to red.

This was also fixed in IE8.

### Summary

We're actually really fortunate that the attribute selector is supported in IE7.  It's a very useful tool to have available and it can help solve a lot of real world issues.  And if you've dropped IE6 support they're finally safe to use.

While support is buggy, the attribute selector does work for the vast majority of use cases.  However, knowing to look out for these bugs can save hours of frustration.  Yet another reason for IE7 to fall off the face of the Earth.  Happy hacking.

]]></content>
  </entry>
  
</feed>
